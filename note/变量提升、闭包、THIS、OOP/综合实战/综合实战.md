# 练习题延伸

## [01~05]

- 1.

```javascript
console.log(a); 
var a=12; 
function fn(){
    console.log(a); 
    var a=13;   
}
fn();   
console.log(a);

/*
 A、undefined  12 13             
 B、undefined undefined 12   
 C、undefined undefined 13         
 D、有程序报错
*/
//=> B
```
- 2.

```javascript
console.log(a); 
var a=12;
function fn(){
    console.log(a);
    a=13;
}
fn();
console.log(a);

/*
 A、undefined  12 13             
 B、undefined undefined 12   
 C、undefined undefined 13         
 D、有程序报错
*/
//=> A
```
- 3.

```javascript
console.log(a);
a=12;
function fn(){
    console.log(a);
    a=13;   
}
fn();
console.log(a);

/*
 A、undefined  12 13             
 B、undefined undefined 12   
 C、undefined undefined 13         
 D、有程序报错
*/
//=> D
```
- 4.

```javascript
var foo=1; 
function bar(){
    if(!foo){
        var foo=10; 
    }
    console.log(foo); 
}
bar();

/*
 A、1     
 B、10     
 C、undefined    
 D、报错
*/
//=> 10
```
> 解析:

```javascript
/**
 * 变量提升:
 *  var foo;
 *  bar aaafff000;
 */
var foo=1; 
function bar(){
    /**
     * 形参赋值: 无
     * 变量提升:
     *      var foo; (不管条件是否成立, 都要进行变量提升, 新浏览器中对于判断体中的函数只是提前声明)
     */
    if(!foo){//=> !undefined => true
        var foo=10; 
    }
    console.log(foo); 
}
bar();
//=> 10
```
- 5.

```javascript
var n=0; 
function a(){
    var n=10; 
    function b(){
        n++; 
        console.log(n); 
    }
    b();
    return b; 
}
var c=a();
c(); 
console.log(n);


/*
 A、1 1 1   
 B、11 11 0  
 C、11 12 0  
 D、11 12 12
*/
//=> C
```

> 解析:

<img src="media/5.png">

## [06~08]js中的严格模式和ARG的映射机制

- 6.

```javascript
var a=10,b=11,c=12;
function test(a){
     a=1;
     var b=2;
     c=3;
}
test(10);
console.log(a);  
console.log(b);   
console.log(c);

/*
 A、1 11 3   
 B、10 11 12  
 C、1 2 3   
 D、10 11 3
*/
//=> D
```
- 7.

```javascript
if(!("a" in window)){
   var a=1;
}
console.log(a);

/*
A、1   
B、undefined   
C、报错   
D、以上答案都不对
*/
```
> 解析

```javascript
/**
 * 变量提升:
 *      var a; 不管条件是否成立都要进行变量提升, 在全局作用域下声明的变量, 也相当于给window设置了一个对象的属性, 而且两者之间建立了映射的机制<=> window.a=undefined;
 */
if(!("a" in window)){//=> 'a' in window =>true
   var a=1;
}
console.log(a);
```

- 8.

```javascript
var a=4;
function b(x,y,a) {    
     console.log(a); 
     arguments[2]=10;       
     console.log(a); 
}
a=b(1,2,3);   
console.log(a); 

/*
 A、3  3  4   
 B、3  10  4   
 C、3  10  10   
 D、3  10  undefined
*/
```
> 解析

```javascript
var a=4;
function b(x,y,a) {
    /**
     * 形参赋值: x = 1 y = 2 a = 3
     * 变量提升
     */
     console.log(a);//=> 3
     arguments[2] = 10;//=> 把传递的第三个实参值修改为10, 此时第三个形参变量a也会受到影响
     console.log(a);//=> 10
}
a=b(1,2,3);//=> a=b执行的结果 => a = undefined [b函数中并没有编写return, 所以默认函数的返回值是undefined]

console.log(a); 
```

#### arguments映射机制

- arguments: 函数内置的实参集合, 不管是否设置形参, 传递的实参值在这个集合中都存在
> arguments
> {
>  0: 1
>  1: 2
>  2: 3
>  length: 3
>  callee: 函数本身
>  ...
> }
>
> **在js非严格模式下**, 函数中的形参变量和arguments存在映射机制(映射: 互相之间影响)
>  第一个形参变量值修改为100, 那么arg[0]的值也跟着修改为100
>  arg[1]的值修改为200, 那么第二个形参变量y的值也会跟着变为200
>  ...

- 同类题

> arguments 和形参之间的映射是以arguments 的索引为基础完成的, arguments 中有这个索引, 浏览器会完成和对应形参变量中的映射机制搭建, 如果形参比arguments 中个数多, 那么多出来的形参是无法和arguments 中对应的索引建立关联的

```javascript
function fn (x, y) {
    /**
     * 形参
     *  x = 10
     *  y = undefined y也是私有变量, 不是没赋值, 而是赋值为undefined
     * 
     * arg
     *  0: 10
     *  length: 1
     * 
     */
    var arg = arguments;
    arg[0] = 100;
    console.log(x);//=> 100
    y = 200;
    console.log(arg[1]);//=> undefined
}
fn(10);
```

> arguments和形参的映射机制建立在函数执行后形参赋值的一瞬间, 此时能建立映射机制的建立映射机制, 不能建立起来的, 以后不管怎么操作都无法再建立了

```javascript
function fn (x, y) {
    var arg = arguments;
    arg[0] = 100;
    console.log(x);//=> 100
    console.log(y);//=> undefined
    arg[1] = 20;
    console.log(arg);
    //=> 0: 100
    //	 1: 20
    console.log(y);//=> undefined
    y = 400;
    console.log(arg[1]);//=> 20
    //=> arguments和形参的映射机制建立在函数执行后形参赋值的一瞬间, 此时能建立映射机制的建立映射机制, 不能建立起来的, 以后不管怎么操作都无法再建立了
}
fn(10);
```

#### js严格模式

- 在当前作用域的"第一行" 添加 "use strict" 即可, 这样在当前作用域中就开启了js的严格模式(不常用)

> 整个js都开启了严格模式(只对当前这个js文件中的代码生效, 下一个js文件需要开启严格模式, 第一行还需要再次编写), 真实项目中, 我们一般都会把所有js文件合并压缩为一个导入到页面中

```javascript
"use strict";
```

- 只在当前作用域中使用严格模式(常用)

```javascript
function fn () {
    "use strict";
}
```

> 工作的时候, 如果有的人不按严格模式, 有的人按严格模式写,就要在当前作用域中使用严格模式, 因为后期js文件合并要互不影响.

```javascript
~function () {
    "use strict";
    //...
}();
```

```javascript
~function () {
    
}();
```

> 合并

```javascript
~function () {
    "use strict";
    //...
}();
~function () {
    
}();
```

- 严格模式和非严格模式的区别

> 1. 在严格模式下不支持使用 arguments.callee/ arguments.callee.caller   (报错: Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them)
> 2. 在严格模式下arguments和形参没有映射机制
> 3. 在严格模式下不允许给一个对象设置重复属性名的: "obj={n:10,n:20}"
> 4. 在严格模式下, 函数执行, 如果没有明确指定执行的主体(函数前面没有点), 不再像非严格模式下一样, 统一都交给window, 而是让this指向 undefined, 代表没有执行主体: " 严格模式下, 有执行主体this就指向谁, 没有执行主体, this就是undefined"(高程717页有汇总, 不全)

```javascript
// 非严格模式
~function () {
    // function fn (x) {
    //     arguments[0] = 100;
    //     console.log(x);//=> 100 存在映射机制
    // }
    // fn(10);

    // var obj = {
    //     n: 10,
    //     n: 20
    // };
    // console.log(obj.n);

    function fn () {
        console.log(this);//=> window
    }
    fn();
    
}();
// 严格模式
~function () {
    "use strict";
    // function fn (x) {
    //     arguments[0] = 100;
    //     console.log(x);//=> 10 不存在映射机制
    // }
    // fn(10);

    // var obj = {
    //     n: 10,
    //     n: 20
    // };
    // console.log(obj.n);

    function fn () {
        console.log(this);//=> undefined
    }
    fn();
}();
```

## [09]逻辑或和逻辑与

- 9.

```javascript
var foo='hello'; 
(function(foo){
   console.log(foo);
   var foo=foo||'world';
   console.log(foo);
})(foo);
console.log(foo);

/*
 A、hello hello hello   
 B、undefined world  hello   
 C、hello world world   
 D、以上答案都不正确
*/
//=> A
```
- 解析:

```javascript
var foo = 'hello';
(function (foo) {
    /**
     * 形参赋值: foo = 'hello'
     * 变量提升: var foo;(这一步省略: 因为在私有作用域中已经有foo这个变量了, 浏览器不会重新声明重复的变量)
     */
    console.log(foo);//=> hello
    var foo = foo || 'world';//=> 'hello' || 'world' => foo = hello
    console.log(foo);//=> hello
})(foo);// 把全局下的foo的值作为实参传递给函数的形参 => 'hello'
console.log(foo);//=> hello
```
### 在条件判断中使用

> 条件中的&&: 两个条件都成立, 整体判断条件才会成立
>
> 条件中的||: 只要有一个条件成立, 整体判断条件就成立

```javascript
if (1===1 && 2===2) {
    
}
```

### 在赋值操作中使用

> "A || B": 先验证A的真假, 为真结果是A, 为假结果是B
>
> "A && B": 先验证A的真假, 为真结果是B, 为假结果是A

```javascript
var a = 1 || 2;
console.log(a);//=> 1

console.log(1 && 2);//=> 2
console.log(1 && 0);//=> 0
console.log(1 && false);//=> false
console.log(0 || 1);//=> 1
```

- 逻辑或 || 的应用

> "给形参赋值默认值": 验证传递的参数值, 如果没有传递实参, 让其默认值为零
>
> 可以使用:
>
> if (x === undefined) {
> ​    x = 0;
> }
> // '=='的话会出现问题, 因为 null == undefined成立.
>
> 也可以使用:
>
> if (typeof x === 'undefined') {
> ​    x = 0;
> }.
>
> 也可以使用:(更常用, 不严谨)
>
> x = x || 0;

```javascript
function fn (x) {
    x = x || 0;//=> 如果x没传递值, x=undefined => x = undefined || 0
    // 这种赋值的方式没有上面if判断严谨,if这种是没传递值才会赋值默认值, ||这种是不传值或者传递的值是假, 都让它等于零(实际开发用的最多)
}
```

- 逻辑与 && 的应用

> 验证有没有传函数, 验证其执行不执行
>
> 可以使用:
>
> if (typeof callback==='function'){
> ​	callback();
> }
>
> 也可以使用:
>
> callback && callback();   (常用, 不严谨)

```javascript
function fn (callback) {
    
    callback && callback();//=> 上面if判断的简写版(不严谨): 默认callback要不然就传函数, 要不然就不传
}
fn(function () {});
```

### &&和||混合应用模式

> 优先级: 逻辑与的优先级高于逻辑或

```javascript
console.log(0 || 1 && 2 || 0 || 3 && 2 || 1);
// 0 || 2 || 0 || 2 || 1
// 2 || 0 || 2 || 1
// 2 || 2 || 1
// 2 || 1
// 2
```

### 逻辑或的实战应用

- 形参赋值默认初始化(初始化形参)

> 在ES6 新语法规范中可以直接给形参设置默认值

```javascript
function fn (x = 0) {
	// 如果x没有传递值, 默认值是零, 一旦传递值, 不管传递的是什么, 都是按照传递的值处理的.(除了undefined.传递undefined, 浏览器也是按照没有传递值处理的)
}
fn();//=> 0
fn(null);//=> null
fn(undefined);//=> 0 


```



## [10]有关堆栈内存释放

- 10.

```javascript
var a=9; 
function fn(){ 
    a=0;       
    return function(b){ 
        return b+a++; 
    }    
}
var f=fn();
console.log(f(5));
console.log(fn()(5));
console.log(f(5));
console.log(a);

/*
 A、6 6 7 2   
 B、5 6 7 3   
 C、5 5 6 3   
 D、以上答案都不正确 
*/
//=> D   5 5 6 2
```

- 解析

> 1. 只要是return返回的就不销毁吗?
>
> 如果return的是一个基本数据类型, 返回就销毁
>
> 如果return的是一个引用数据类型, 返回不能销毁, 因为传递的是地址, 地址内的东西被其它地方占用.
>
> 2. bbbfff000中和bbbfff111中出现 形参: b, 是不存在的, 为了好理解写上的.堆内存中实际只有代码字符串.

<img src="media/10.png">

## [11~13]

- 11.

```javascript
var ary=[1,2,3,4];
function fn(ary){
    ary[0]=0;    
    ary=[0];    
    ary[0]=100;    
    return ary; 
}
var res=fn(ary);    
console.log(ary);    
console.log(res);
```
- 解析
> **私有变量和全局变量没有直接关系, 但是会存在间接关系, 全局变量给函数赋值了地址, 都操作的同一个空间. 函数在形成了一个闭包后, 会切断私有变量和全局变量的干扰, 当这种切断是切断的直接干扰,仍然会有间接的干扰**
```javascript
/**
 * 变量提升:
 *  var ary;
 *  fn = aaafff111;
 *  var res;
 */
var ary = [1, 2, 3, 4];//=> ary = bbbfff111[ary全局变量] [0, 2, 3, 4]
function fn(ary) {
    /**
     * 形参赋值: ary = bbbfff111 [ary是私有变量]
     */
    ary[0] = 0;
    ary = [0];//=> ary = bbbfff222  [0(100)]
    ary[0] = 100;
    return ary;//=> bbbfff222
}
var res = fn(ary);//res = fn(bbbfff111) = bbbfff222
console.log(ary);//=>[0, 2, 3, 4]
console.log(res);//=> [100]

//=> [0, 2, 3, 4]
//	 [100]
```
- 12.

```javascript
function fn(i) {
    return function (n) {
        console.log(n + (i++));
    }
}
var f = fn(10);
f(20);
fn(20)(40);
fn(30)(50);
f(30);
```
> 解析

```javascript
/**
 * 变量提升:
 * fn = aaafff111;
 * var f;
 */
function fn(i) {
    /**
     * 第一次aaafff111执行:
     * i = 10;(11)
     * return bbbfff111
     */
    /**
     * 第二次aaafff111执行:
     * i = 20;(21)
     * return bbbfff222
     */
    /**
     * 第三次aaafff111执行:
     * i = 30;(31)
     * return bbbfff333;
     */
    return function (n) {
        /**
         * 第一次bbbfff111执行:
         * n = 20
         * => 20 + (i++)=20 + 10=30
         */
        /**
         * 第二次bbbfff222执行:
         * n = 40;
         * => 40 + (i++)=40 + 20=60
         */
        /**
         * 第三次bbbfff333执行:
         * n = 50;
         * => 50 + (i++)=50 + 30=80
         */
        /**
         * 第四次bbbfff111执行:
         * n = 30;
         * => 30 + (i++)= 30 +11=41
         */
        console.log(n + (i++));
    }
}
var f = fn(10);
f(20);//=> 30
fn(20)(40);//=> 60
fn(30)(50);//=> 80
f(30);//=> 41
//=> 30  60  80  41
```

- 13.

```javascript
var i = 10;
function fn() {
    return function (n) {
        console.log(n + (++i));
    }
}
var f = fn();
f(20);//=> 31
fn()(20);//=> 32
fn()(30);//=> 43
f(30);//=> 44
//=> 31 32 43 44
```

## [14]堆栈内存和this混合应用

- 14.

```javascript
var num = 10;
var obj = {num: 20};
obj.fn = (function (num) {
    this.num = num * 3;
    num++;
    return function (n) {
        this.num += n;
        num++;
        console.log(num);
    }
})(obj.num);
var fn = obj.fn;
fn(5);
obj.fn(10);
console.log(num, obj.num);
```

> 解析:

<img src="media/14.png">

- 改题目

```javascript
var num = 10,  
    obj = {num: 20};
obj.fn = (function (num) { 
    num = this.num + 10;
    this.num = num + 10;
    return function () {
        this.num += ++num;
    }
})(num);
var fn = obj.fn;
fn();
obj.fn();
console.log(num, obj.num);
//=> 51 42
```

> 解析

```javascript
/*
 * 变量提升：
 *   var num;
 *   var obj;
 *   var fn;
 */
var num = 10,
    obj = {num: 20};//=>obj=aaafff000   =>{num:20,fn:bbbfff000}
obj.fn = (function (num) {
    /*
     * num=10
     * this->window
     */
    num = this.num + 10;//=>num=20 (21) (22)
    this.num = num + 10;//=>window.num=30

    return function () {//=>bbbfff000
        /*
         * fn()
         *   this->window
         *   window.num+= ++num; //=>window.num=51
         */
        /*
         * obj.fn()
         *   this->obj
         *   obj.num+= ++num; //=>obj.num=42
         */
        this.num += ++num;
    }
})(num);
var fn = obj.fn;//=>fn=bbbfff000
fn();
obj.fn();
console.log(num, obj.num);
```

## [15]构造函数和原型链的运行机制

- 1 和 new Number(1) 

> 区别
> ​	前面是一个基本数据类型值
>
> ​	后面是一个引用数据类型值（对象）
> 相同点：	
>
> ​	都是Number这个类的实例

- 函数类型 和 对象类型

> 函数类型
>
> ​	普通函数
>
> ​	构造函数(类: 内置类和自己创建的类)
>
> 对象类型:
>
> ​	普通对象
>
> ​	Math \ JSON ...
>
> ​	类的实例
>
> ​	prototype 或者 \__proto__
>
> ​	arguments或者 元素集合等类数组
>
> ​	函数也是一种对象
>
> ​	...
>
> ​	=> 万物皆对象

- 原型和原型链汇总

> 1. 每一个函数(类)都有一个prototype(原型)属性, 属性值是一个对象: 这个对象中存储了当前类供实例调取使用的公有属性和方法
> 2. 在"浏览器默认"给原型开辟的堆内存中有一个属性constructor: 存储的是当前类本身
> 3. 每一个对象(实例)都有一个\__proto__(原型链)属性, 这个属性指向当前实例所属类的原型(不确定所属的类, 都指向Object.prototype)

- 15.

```javascript
function Fn() {
    this.x = 100;
    this.y = 200;
    this.getX = function () {
        console.log(this.x);
    }
}
Fn.prototype.getX = function () {
    console.log(this.x);
};
Fn.prototype.getY = function () {
    console.log(this.y);
};
var f1 = new Fn;
var f2 = new Fn;
console.log(f1.getX === f2.getX);//=> false
console.log(f1.getY === f2.getY);//=> true
console.log(f1.__proto__.getY === Fn.prototype.getY);//=> true
console.log(f1.__proto__.getX === f2.getX);//=> false
console.log(f1.getX === Fn.prototype.getX);//=> false
console.log(f1.constructor);// Fn (f1通过__proto__属性向上查找所属类的prototype属性有 constructor属性)
console.log(Fn.prototype.__proto__.constructor);//=> Object
f1.getX();//=> this:f1   100
f1.__proto__.getX();//=> this:f1.__proto__   => console.log(f1.__proto__.x) => undefined  (向Object.prototype查找也没有y属性)
f2.getY();//=> this:f2 => console.log(f2.y) => 200
Fn.prototype.getY();//=> this:Fn.prototype => console.log(Fn.prototype.y) => undefined  (向Object.prototype查找也没有y属性)
```

- 展开理解

<img src="media/15.png">

> 函数存储在堆内存中, 不仅有代码字符串, 还有prototype, name, length属性
>
> length属性: 函数参数的个数
>
> name属性: 函数的名字
>
> 但这两个属性没什么用

```javascript
function Fn() {
    this.x = 100;
    this.y = 200;
    this.getX = function () {
        console.log(this.x);
    }
}
```



![1544710778450](media/1544710778450.png)

```javascript
function Fn(a, b, c) {
    this.x = 100;
    this.y = 200;
    this.getX = function () {
        console.log(this.x);
    }
}
```

![1544711015247](media/1544711015247.png)

