# H5的知识点梳理

T1.1~1.3  P1~P3  初级

T2.1~2.3  P4~P6  中高级

T3.1~3.3  P7~P9  架构师

## H5的知识点梳理-常用标签和表单

1.新增加(删除/修改)的语义化标签

- 常用:

header 头部

footer 尾部

main 主体

section 区域

article 文章区域

aside 与内容无关的部分(例如: 广告)

nav 导航

figure 配图区域

figcaption 配图说明

- 不常用:

mark 标记

time 时间标记

progress 进度条

...

2.关于表单元素的新改革

- [传统表单元素]

input: text/password/radio/checkbox/file/hidden/button/submit/reset...

select

textarea 文本域

button

form

label 

...

- [新增一些表单元素或者是表单类型]

input:search搜索框/email邮箱框/tel/number/range滑动杆/color/date/time/url地址框...

```html
<!-- 
数字框 非数字输入不进去 disabled不可更改
-->
<input type="number" id="ageInp" step="1" max="65" min="18" value="25" disabled>
滑动条
<input type="range" id="rangeInp" step="1" max="65" min="18" value="25">
<script>
    //change事件: 改变才会改, 滑动期间不会随时改变
    rangeInp.onchange=function(){
        let val=this.value;
        ageInp.value=val;
    }
    //input事件:移动端没有key-down/key-up用input代替, 代表正在操作当前表单元素(例如正在输入等) 滑动会随时改变
    rangeInp.oninput = function () {
        let val = this.value;
        console.log(val)
        ageInp.value = val;
    }
</script>
```

选颜色框

```html
<input type="color" name="" id="colorInp" />
<script>
    colorInp.onchange = function() {
        console.log(this.value); //=> 16进制颜色值
    }
</script>
```

- 表单元素中新增加的类型作用

  1.功能强大了(很多东西不需要自己导入JS插件完成了, 例如:日历)

  2.在移动端根据设置的类型不一样, 用户输入过程中调取出来的虚拟键盘也不一样(例如: number类型的文本框调取出来的是数字键盘. 输入邮箱的时候有email类型调取出来的键盘有特殊符号)

  3.新增加的类型提供了CSS/JS验证, 可以验证用户输入的内容是否符合格式(之前我们都是用正则自己解决, 现在H5中的新类型自带验证机制)

  虽然自带验证，但是开发还是拿正则

用css做表单验证

```html
<style>
    #userEmail {
        border: 1px solid #ddd;
        outline: none; /* 当文本框获取焦点后去除浏览器默认的边框选中颜色 */
    }
    #userEmail:valid {
        /*通过验证：不输入或者输入正确*/
        border-color: green;
    }
    #userEmail:invalid {
        /*没通过验证*/
        border-color: red;
    }
    #userEmail:valid + span:after {
        content: '邮箱格式正确';
    }
    #userEmail:invalid + span:after {
        content: '邮箱不符合格式';
    }
</style>
<input type="email" id="userEmail" />
<span></span>
```

用js做表单验证

```html
<input type="email" id="userEmail" />
<span id="spanEmail"></span>
<script>
    userEmail.onkeyup = function() {
        //=> checkValidity: H5新提供的表单内容格式验证方法（新表单类型中有内置验证机制的，都可以基于这个方法验证）
        if (this.checkValidity()) {
            spanEmail.innerHTML = 'OK'
        } else {
            spanEmail.innerHTML = 'NO'
        }
    }
</script>
```

正常的js验证

- H5中给表单元素设置了一个新的属性：placeholder 用来做文本框的默认提示的（自己扩展：使用JS实现一套和PLACE-HOLDER一模一样的效果）

```html
<input type="email" id="userEmail" placeholder="请输入邮箱！" />
<span id="spanEmail"></span>
<script>
    // blur: 失去焦点
    // focus:获得焦点
    userEmail.onkeyup = userEmail.onblur = function() {
        let val = this.value.trim() // 去掉字符串的首位空格
        let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/
        if (val.length === 0) {
            spanEmail.innerHTML = '必填'
            return
        }
        if (!reg.test(val)) {
            spanEmail.innerHTML = 'NO'
            return
        }
        spanEmail.innerHTML = 'OK'
    }
</script>
```

下拉框：

```html
<!-- 下拉框（扩展：实现一个三级联动） -->
地区：
<select name="" id="selectCity">
    <option value="">==请选择==</option>
    <option value="北京">北京</option>
    <option value="上海">上海</option>
    <option value="广州">广州</option>
    <option value="深圳">深圳</option>
    <option value="杭州">杭州</option>
    <option value="成都">成都</option>
</select>
```

输入框带模糊匹配

```html
<input list="cars" id="myCar">
<datalist id="cars">
    <option value="BMW"></option>
    <option value="Ford"></option>
    <option value="Volvo"></option>
</datalist>
```

## H5和CSS3知识点梳理-CSS3常用的基本属性

### HTML5

3.音视频标签

​    audio

​    video

​    让我们告别了FLASH时代

4.canvas图形绘制

5.提供了一些新的API

​      本地存储：localStorage/sessionStorage

​      获取地理位置：navigator.geolocation.getCurrentPosition 调取手机内部的GPS定位系统获取当前手机所在地的经纬度以及精确度等

​      定位方式：基站定位、IP定位、GPS定位

​      ...

​      还提供了一些，让我们可以通过浏览器调取手机内部的软件或者硬件（但是性能都不怎么高，而且兼容性不是很好）

6.webSocket: socket.io 客户端和服务器新的传输方式（即时通讯IM系统基本上很多是基于它完成的）

### CSS3

#### 选择器

​        \#ID

​        .CLASS

​        TAG

​        *

​        SELECTOR1,SELECTOR1... 群组选择器

​        A B {} 后代

​        AB {} 既具备A也具备B的（同级二级筛选）

​        A>b {} 子代

​        A+B {} 下一个弟弟

​        A~B {} 兄弟

​        A[NAME=''] 属性选择器

​          A[NAME!='']

​          A[NAME^='']

​          A[NAME$='']

​          A[NAME*='']

​        

​        A:link 未访问的链接

​        A:hover 当有鼠标悬停在链接上

​        A:active 被选择的链接

​        A:visited 已访问的链接

​        A:after

​        A:before

​        A:nth-child 

​        A:nth-last-child

​        A:nth-of-type

​        A:nth-last-of-type

​        A:not

​        A:first-child

​        A:last-child

​        ...

​      

#### 样式属性

1.基本常用

​        border-radius

​        box-shadow

​        text-shadow 文本阴影

2.背景

​        backgorund -color / -image / -attachment / -position / -repeat

​        background-size:

​            100px 100px 宽高具体值

​            100% 100% 宽高百分比

​            cover 以合适的比例把图片进行缩放（不会变形），覆盖整个容器

​            contain 背景图覆盖整个容器（但是会出现，如果一边碰到容器的边缘，则停止覆盖，导致部分区域是没有背景图的）

​            ...

​        background -clip: 背景图片裁切

​            border-box

​            padding-box

​            content-box

​        background-origin: 设置背景图的起始点

​            border-box

​            padding-box

​            content-box

​        filter: 滤镜

​            none | blur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity() | saturate() | sepia() | url();

3.CSS3动画和变形（2D/3D）

​          //=>变形不是动画

​          transform: 变形

​            translate(X|Y|Z) 偏移

​            scale 缩放

​            rotate 旋转

​            skew 倾斜

​            matrix 矩阵（按照自己设定的矩阵公式实现变形）

​          transform-style:preserve-3d 实现3D变形

​          trransform-origin: 变形的起点

​          //=>过渡动画

​          transition:

​            transition-property:all/width...哪些属性样式发生改变执行过渡动画效果，默认all，所有样式属性改变都会执行这个过渡效果

​            transition-duration:过渡动画的时间，一般都用秒 例如：.5s

​            transition-timing-function:动画运动的方式 

​              linear(默认) ease|ease-in|ease-out|ease-in-out|cubic-bezier(执行自己设定的贝塞尔曲线)

​            transition-delay:设置延迟的时间，默认是0s不延迟，立即执行动画

​            ...

​          //=>帧动画

​          animation:

​            animation-name 运动轨迹的名称

​            animation-duration 运动的时长

​            animation-timing-function 运动的方式(默认ease)

​            animation-delay 延迟时间

​            animation-iteration-count 运动次数(默认1 infinite无限次运动)

​            animation-fill-mode 运动完成后的状态(帧动画完成后，元素会默认回到运动的起始位置，如果想让其停留在最后一帧的位置，设置这个属性值为forward; backwards是当前帧动画如果有延迟时间，在延迟等待时间内，元素处于帧动画的第一帧位置; both是让帧动画同时具备forwards和backwards)

​            ...

​          //=>设置帧动画的运动轨迹

​          @keyframes [运动轨迹名称] {

​            from{

​              //开始的样式

​            }

​            to{

​              //结束的样式

​            }

​          }

​          @keyframes [运动轨迹名称] {

​            0%{

​              //开始的样式

​            }

​            50%{}

​            100%{

​              //结束的样式

​            }

​          }

​        

4.CSS3中的新盒子模型

​          box-sizing:border-box / padding-box / content-box(默认) 改变的width和height代表的是什么

​          columns:多列布局

​          flex:弹性盒子模型

5.一些其他的CSS3属性

​          perspective:视距 实现3D动画必用的属性

​          @media:媒体查询 实现响应式布局的一种方案

​          @font-face:导入字体图标

​          ...

## 简述REM响应式布局原理

响应式布局：在不同尺寸的设备上都能良好的展示，这就是响应式布局设计(Responsive Layout)
公司中的产品形态：
  1.PC端（全屏页面需要宽度自适应，但是一般都是固定宽度的）
  2.PC+移动端用同一套项目（简单的页面，例如：产品介绍，公司展示类的官网等）
  3.移动端
    嵌入到APP中的H5
    微信中分享出来的H5
    微信公众号
    小程序
    靠浏览器访问的H5
    ...
  4.RN(React Native) / ionic / cordova ... JS开发APP的框架，使用JS代码开发APP，最后框架会把代码转换为 安卓和IOS 需要的代码



如何实现响应式布局开发？

​      最常用的方案：REM等比缩放响应式布局

​      做移动端H5开发，首先加meta标签

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

​        REM和PX一样都是样式单位，PX是固定单位，REM是相对单位（相对于当前页面根元素HTML的字体设定的单位）

​        我们开始给HTML的字体大小设置为100px(1rem=100px)，接下来我们写样式的时候，把所有的尺寸都用REM设定（测量出来的PX值/100就是应该设置REM的值），如果HTML的FONT-SIZE不变，用REM和PX一样，但是如果字体大小改变，也就是改变了REM和PX之间的换算比例，那么之前所有用REM做单位的样式都会自动按照最新的比例进行缩放（实现了改动HTML的FONT-SIZE，整个页面中的元素都跟着缩放了，牵一发而动全身）

​        真实项目中，设计师给我们一套设计稿（常用的尺寸：640 * 1136 750 * 1334 640 * 960 ...），拿到设计稿后，我们严格按照设计稿中的尺寸去编写样式

​          html{font-size:100px}

​          接下来写样式，把测量出来的px都除以100变为REM，所有的单位基于REM来搞

​        假设设计稿是750，也就相当于750的设备下，1rem=100px

​          我们页面运行在320的设备上，我们需要修改HTML的字体大小，以此实现页面跟着整体缩放：320/750*100 => 当前设备上HTML的字体大小

```html
<style>
    html {
        /* 
        1.最好不要写10：浏览器默认最小的字体是12px
        2.font-size设置为多少，相当于1rem等于多少像素
        3.之所以设置为100px,就是为了方便计算rem和px转换的比例
        */
        font-size: 100px;/* 1rem=100px */
    }
    .box1 {
        margin: .2rem;
        width: 100px;
        height: 100px;
        background: lightcoral;
    }
    .box2 {
        margin: 20px;
        width: 200px;
        height: 200px;
        background: lightgreen;
    }
    .box3 {
        margin: 20px;
        width: 300px;
        height: 300px;
        background: lightblue;
    }
</style>
<div class="box1"></div>
<div class="box2"></div>
<div class="box3"></div>
```